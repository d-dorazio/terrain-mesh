use std::collections::HashMap;
use std::io;
use std::io::Write;

use crate::arena::{Arena, ArenaId};
use crate::bvh::Bvh;
use crate::geo::{BarycentricCoords, Bbox, Circle, Vec2};

pub type TriangleId = ArenaId<Triangle>;
pub type VertexId = ArenaId<Vertex>;

#[derive(Debug)]
pub struct DelaunayMesh {
    triangles: Arena<Triangle>,
    vertices: Arena<Vertex>,
    triangles_index: Bvh<TriangleId>,

    // bbox of the points that are to be inserted in the mesh. Doesn't take into account the
    // padding for the initial super triangles.
    input_bbox: Bbox,
}

#[derive(Debug)]
pub struct Triangle {
    vertices: [VertexId; 3],
    circumcircle: Circle,
}

#[derive(Debug)]
pub struct Vertex {
    position: Vec2,
}

impl DelaunayMesh {
    pub fn new(mut bbox: Bbox) -> Self {
        let input_bbox = bbox;

        // add a bit of padding to account for the super triangles and to avoid degenerate
        // triangles.
        bbox.enlarge(20.0);

        let mut dm = DelaunayMesh {
            triangles: Arena::new(),
            vertices: Arena::new(),
            triangles_index: Bvh::new(bbox),
            input_bbox,
        };

        let min = bbox.min();
        let max = bbox.max();

        let tl = dm.vertices.push(Vertex::new(min));
        let tr = dm.vertices.push(Vertex::new(Vec2::new(max.x, min.y)));
        let bl = dm.vertices.push(Vertex::new(Vec2::new(min.x, max.y)));
        let br = dm.vertices.push(Vertex::new(max));

        dm.insert_triangle(tl, br, tr);
        dm.insert_triangle(br, tl, bl);

        dm
    }

    pub fn triangles(&self) -> impl Iterator<Item = (TriangleId, &Triangle)> {
        // exclude initial super triangles
        self.triangles
            .enumerate()
            .filter(move |(_, t)| !self.is_super_triangle(t))
    }

    pub fn triangle_vertices(&self, id: TriangleId) -> [Vec2; 3] {
        let vs = self.triangles[id].vertices;

        [
            self.vertices[vs[0]].position,
            self.vertices[vs[1]].position,
            self.vertices[vs[2]].position,
        ]
    }

    pub fn enclosing_triangle(&self, p: Vec2) -> Option<&TriangleId> {
        self.triangles_index
            .enclosing(p, |t, p| {
                BarycentricCoords::triangle(self.triangle_vertices(*t), p).is_some()
            })
            .next()
    }

    pub fn insert(&mut self, p: Vec2) {
        //
        // The idea here is to first find all the triangles whose circumcircle contains the new
        // point.
        //
        // Such triangles are then removed from the triangulation and replaced by a new set of
        // triangles that are generated by connecting the edges of the boundary of the removed
        // triangles to the new point.
        //
        //
        // Example
        //
        // ⡟⢍⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⡇       ⡏⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⡇       ⡟⠫⡉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⡹⡇
        // ⡇⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇       ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇       ⡇⠀⠈⠑⠤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡔⠁⡇
        // ⡇⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇       ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇       ⡇⠀⠀⠀⠀⠈⠒⢄⡀⠀⠀⠀⠀⠀⠀⠀⢀⠜⠀⠀⡇
        // ⡇⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇       ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇       ⡇⠀⠀⠀⠀⠀⠀⠀⠈⠢⢄⠀⠀⠀⠀⢀⠎⠀⠀⠀⡇
        // ⡇⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇       ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇       ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠢⣀⢠⠃⠀⠀⠀⠀⡇
        // ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠁⠀⠀⠀⠀⠀⡇  ==>  ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⡇  ==>  ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠒⠱⡀⠀⠀⠀⠀⡇
        // ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⠀⠀⡇       ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇       ⡇⠀⠀⠀⠀⠀⠀⠀⠀⡠⠔⠉⠀⠀⠀⠑⡄⠀⠀⠀⡇
        // ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⠀⠀⡇       ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇       ⡇⠀⠀⠀⠀⠀⣀⠔⠊⠀⠀⠀⠀⠀⠀⠀⠘⢄⠀⠀⡇
        // ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠀⠀⡇       ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇       ⡇⠀⠀⢀⠤⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢆⠀⡇
        // ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⡇       ⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇       ⣇⡠⠊⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢣⡇
        // ⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠁       ⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠁       ⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠁
        // current triangulation       remove intersecting         re-triangulate the boundary
        //                             triangles and find the      connecting its edges to
        //                             boundary of those           the new point
        //                             triangles
        //
        // Note that the circumcircles are not drawn for simplicity, just assume the point lies
        // inside the circumcircles of both triangles.
        //

        use std::collections::HashSet;
        let enclosing_triangles = self
            .triangles_index
            .enclosing(p, |&tid, p| self.triangles[tid].circumcircle.contains(p))
            .cloned()
            .collect::<HashSet<_>>();
        // let enclosing_triangles2 = self
        //     .triangles
        //     .enumerate()
        //     .filter_map(|(tid, t)| {
        //         if t.circumcircle.contains(p) {
        //             Some(tid)
        //         } else {
        //             None
        //         }
        //     })
        //     .collect::<HashSet<_>>();
        // assert_eq!(enclosing_triangles, enclosing_triangles2);

        let boundary = self.triangles_boundary(&enclosing_triangles);

        for tri in &enclosing_triangles {
            self.remove_triangle(*tri);
        }

        let vp = self.vertices.push(Vertex::new(p));
        for (v0, v1) in boundary {
            self.insert_triangle(v0, v1, vp);
        }
    }

    fn is_super_triangle(&self, t: &Triangle) -> bool {
        t.vertices
            .iter()
            .any(|v| !self.input_bbox.contains(self.vertices[*v].position))
    }

    fn insert_triangle(&mut self, va: VertexId, vb: VertexId, vc: VertexId) -> TriangleId {
        let a = self.vertices[va].position;
        let b = self.vertices[vb].position;
        let c = self.vertices[vc].position;

        let circumcircle = Circle::circumcircle(a, b, c);
        let tri = self.triangles.push(Triangle {
            vertices: [va, vb, vc],
            circumcircle,
        });

        self.triangles_index.insert(tri, circumcircle.bbox());
        tri
    }

    fn remove_triangle(&mut self, tri: TriangleId) {
        self.triangles_index
            .remove(&tri, self.triangles[tri].circumcircle.bbox());

        self.triangles.remove(tri);
    }

    fn triangles_boundary<'t>(
        &self,
        triangles: impl IntoIterator<Item = &'t TriangleId>,
    ) -> impl Iterator<Item = (VertexId, VertexId)> {
        use std::collections::hash_map::Entry;

        //
        // the boundary of the roi is the set of the outer edges that are not shared among the
        // enclosing triangles
        //
        let mut boundary = HashMap::new();

        for tri in triangles.into_iter() {
            let tri = &self.triangles[*tri];

            for v in 0..tri.vertices.len() {
                let edge = (tri.vertices[v], tri.vertices[(v + 1) % tri.vertices.len()]);

                let entry = match boundary.entry(edge) {
                    // be sure to also check the opposite edge
                    Entry::Vacant(_) => {
                        let eo = (edge.1, edge.0);
                        boundary.entry(eo)
                    }
                    o @ Entry::Occupied(_) => o,
                };

                entry.and_modify(|shared| *shared = true).or_insert(false);
            }
        }

        boundary
            .into_iter()
            .filter(|(_, shared)| !*shared)
            .map(|(edge, _)| edge)
    }
}

impl Vertex {
    pub fn new(position: Vec2) -> Self {
        Vertex { position }
    }
}

pub fn dump_svg(out: &mut impl Write, dmesh: &DelaunayMesh) -> io::Result<()> {
    writeln!(
        out,
        r#"<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="{x} {y} {w} {h}">
<rect x="{x}" y="{y}" width="{w}" height="{h}" stroke="none" fill="white" />
             "#,
        x = dmesh.input_bbox.min().x,
        y = dmesh.input_bbox.min().y,
        w = dmesh.input_bbox.max().x - dmesh.input_bbox.min().x,
        h = dmesh.input_bbox.max().y - dmesh.input_bbox.min().y,
    )?;

    for (tri, _) in dmesh.triangles() {
        let [a, b, c] = dmesh.triangle_vertices(tri);

        writeln!(
            out,
            r#"<polygon points="{},{} {},{} {},{}" fill="none" stroke="black" />"#,
            a.x, a.y, b.x, b.y, c.x, c.y
        )?;
    }

    writeln!(out, "</svg>")
}
